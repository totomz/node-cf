const fs = require('fs');
const Promise = require("bluebird");
const Mustache = require("mustache");

const readFile = Promise.promisify(require("fs").readFile);
const exec = Promise.promisify(require('child_process').exec);
const writeFile = Promise.promisify(require('fs').writeFile);
const AWS = require('aws-sdk');
const os = require('os');
const path = require('path');
const YAML = require('yamljs');
const objectPath = require("object-path");


/**
 *
 * @param options {object} Config object
 * @param options.inputFile {string} Patht the file with the template to use as input
 * @param options.action {string} Can be "createStack" or "updateStack"
 * @param options.dryRun {boolean} default TRUE. Call AWS CLoudFormation only if set to false
 * @param options.aws_profile {string} The profile to use for AWS service calls
 * @constructor
 */
function NodeCF(options) {
    this.options = options;


    /*
     readFile() --> ritorna {contents, metadata}
     loadExternals()
     render()
     saveToTemp()
     createCf()

     */
}

/**
 * Read the input files and return the template generated by mustache
 */
NodeCF.prototype.buildTemplate = function () {

    const readFile = (/ya?ml/.test(path.extname(this.options.inputFile)))?this.readFileYaml:this.readFileJson;

    return readFile(this.options.inputFile)
        .then(data => {return this.loadExternals(this.options.inputFile, data)})
        .then(data => {

            // These functions can be called from the template, and can access the metadata template
            const __builtinFunctions = {
                funcTime: function () { return new Date().getTime(); },
                jsonize: function () {
                    return function(val, render) {
                        const obj = objectPath.get(data.metadata.aws.template, val);
                        return render(JSON.stringify(obj));
                    };
                },
                jsonizeEscapeQuotes: function () {
                    return function (val, render) {
                        const obj = objectPath.get(data.metadata.aws.template, val);
                        val = JSON.stringify(obj);
                        return render(val.replace(/"/g, '\\"'));
                    };
                },
                escapeQuotes: function() {
                    return function(val, render) {
                        return val.replace(/"/g, '\\"');
                    };
                }
            };

            // "stages" are particular elements that we want to add to the template metadata.
            // The template may specify additional stages
            data.metadata.aws.template.stages = [].concat(data.metadata.aws.template.stages || [], this.options.stages || []);

            data.metadata.aws.template.funcTime = function () { return new Date().getTime(); };


            /*
                data.metadata contains the variable ("mustache view") that will be subsituted in the template.
                We want to have variables also in the variables (eg: it should be possible to define something like {a: "{{b}} Tom!", b:"hy"})
                Also, externals may contains variables to be interpolated.

                This line of code take the metadata, converts them to text, and apply the mustache view/render using the metadata itself.
                The problem are the builtinFunctions, that are striped away when the template is rendered. So we need to add them twice

                The other problem is taht the externals are defined as STRING, not objects.
             */
            data.metadata.aws.template = Object.assign(data.metadata.aws.template, __builtinFunctions);
            const metadata = data.metadata;
            const metadataAsString = JSON.stringify(metadata);
            const metadataRendered = Mustache.render(metadataAsString,data.metadata.aws.template);
            data.metadata = JSON.parse(metadataRendered);

            // Built-in functions - again
            data.metadata.aws.template = Object.assign(data.metadata.aws.template, __builtinFunctions);

            if(data.metadata.aws.capabilities && typeof data.metadata.aws.capabilities === 'string') {
                data.metadata.aws.capabilities = data.metadata.aws.capabilities.split(" ");
            }

            return data;
        })
        .then(this.render)
};

NodeCF.prototype.validateTemplate = function(data) {
    const {metadata, contents} = data;
    if(this.options.aws_profile) {
        AWS.config.credentials = new AWS.SharedIniFileCredentials({profile: this.options.aws_profile});
    }

    // Rimani si tucco, e' un barbatrucco!
    this.cfClient = new AWS.CloudFormation({ region: metadata.aws.region });

    if(metadata.aws.template.__use_s3) {
        console.log("Uploading template to S3");
        const templateKey = `cftpl/${metadata.aws.template.name}`;
        const params = {
            Bucket: metadata.aws.template.__use_s3,
            Key: templateKey,
            Body: contents
        };
        return new AWS.S3({ region: metadata.aws.region })
            .upload(params).promise()
            .then(s3 =>{
                console.log("Template uploaded to S3. Validating CloudFront Stack");
                return this.cfClient.validateTemplate({
                    TemplateURL: s3.Location
                }).promise().then(() => {return data;});
            });
    }
    else {
        return this.cfClient.validateTemplate({
            TemplateBody: contents
        }).promise().then(() => {return data;});
    }
};

/**
 * Credentials are taken (in order, )
 * - this.aws_profile (http://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/loading-node-credentials-shared.html)
 *
 * The stack name is
 * - the name of the folder that contains the template, or
 * - Metadata.aws.template.name
 *
 * Currently a template can't be larger than 51kB
 *
 * @param template {String} The rendered template
 */

NodeCF.prototype.saveToCloudFormation = function(data) {

    const {metadata, contents} = data;
    const templateMeta = metadata;

    if(!templateMeta.aws.template.name) {
        return Promise.reject(new Error("[BadTemplate] Required field 'Metadata.aws.template.name' not found"))
    }

    if(this.options.dryRun) {
        console.log("!!! DryRun !!!");
        return Promise.resolve(data);
    }

    if(this.options.aws_profile) {
        AWS.config.credentials = new AWS.SharedIniFileCredentials({profile: this.options.aws_profile});
    }

    // Upsert!
    return this.cfClient.describeStacks({StackName: templateMeta.aws.template.name}).promise()
        .then(res => {
            // The stack exists - update!
            this.waitForAcion = 'stackUpdateComplete';      // Round round get around, I (work)around, yeah
            return 'updateStack';
        })
        .catch(err => {
            // It is a brand new stack
            this.waitForAcion = 'stackCreateComplete';      // Round round get around, I (work)around, yeah
            return 'createStack';
        })
        .then(action => {

            // La morte
            if(templateMeta.aws.template.__use_s3) {
                console.log("Uploading template to S3");
                const templateKey = `cftpl/${templateMeta.aws.template.name}`;
                const params = {
                    Bucket: templateMeta.aws.template.__use_s3,
                    Key: templateKey,
                    Body: contents
                };
                return new AWS.S3({ region: templateMeta.aws.region })
                    .upload(params).promise()
                    .then(s3 =>{
                        console.log("Template uploaded to S3. Processing CloudFront Stack");
                        return this.cfClient[action]({
                            StackName: templateMeta.aws.template.name,
                            Capabilities: templateMeta.aws.capabilities,
                            TemplateURL: s3.Location
                        }).promise();
                    });
            }

            const StackName =  templateMeta.aws.template.name; // || path.dirname(templateFile).split(path.sep).pop().match(/(?=[a-z]).*/)[0];
            const TemplateBody = contents;

            return this.cfClient[action]({
                StackName,
                Capabilities: templateMeta.aws.capabilities,
                TemplateBody
            }).promise();

        });
};

/**
 *
 * @param template {string} The template
 * @return {Promise.<{template: string the template, tempFile: string path to the temp file}>}
 */
NodeCF.prototype.saveTempalteToTempFile = function(data){
    const {metadata, contents} = data;
    const tempFile = [os.tmpdir(), path.sep, new Date().getTime(), '_template'].join('');

    console.log(`Template rendered in ${tempFile}`);
    return writeFile(tempFile, contents, 'utf-8')
        .then(data => {
            return {metadata, contents, tempFile}
        });
};


NodeCF.prototype.waitForIt = function(data) {
    console.log("Waiting for the stack to succeed");
    return new Promise( (resolve, reject) => {
        this.cfClient.waitFor(this.waitForAcion, {StackName: data.StackId}, (err, res) => {
            if(err) {
                return reject(err);
            }
            else {
                return resolve(res); // Return a json
            }
        })

    });
};

/**
 * Data object
 * @typedef {Object} Metacontent
 * @property {Object} metadata The template view object
 * @property {String} content The template
 */

/**
 * Parse a file in JSON
 * @param templateFile {String} Path to the template
 * @return {Promise.<Metacontent>}
 */
NodeCF.prototype.readFileJson = function (templateFile) {

    return readFile(templateFile, 'utf-8')
        .then(contents => {

            let index = contents.search(/"Metadata":\s*/) + 10;  // First { after Metadata
            let buffer = [];
            let bracketCounter = 0;
            let char = '';

            do {
                char = contents.charAt(++index);

                buffer.push(char);
                if (char === '{') {
                    bracketCounter++;
                }
                else if (char === '}') {
                    bracketCounter--;
                }

            } while ((bracketCounter !== 0) || (bracketCounter === 0 && char === ' '));

            let dd = buffer.join('');
            let metadata;

            try {
                metadata = JSON.parse(dd);
            }
            catch (err) {
                console.log("********* ERROR *********");
                console.log("Please check this json:");
                console.log(dd);
                throw err;
            }

            return {
                metadata,
                contents
            };
        });

};


NodeCF.prototype.readFileYaml = function(templateFile) {

    return readFile(templateFile, 'utf-8')
        .then(contents => {
            return new Promise((resolve, reject) => {

                // As with JSON, here we care only about the metadata. Don't need to parse the contents,
                // that can be invlaid due to mustache stuff
                const buffer = [];
                const lines = contents.split('\n');
                for(let i=0; i<lines.length; i++) {
                    if(/Resources:/.test(lines[i])){
                        break;
                    }
                    buffer.push(lines[i]);
                }

                const template = YAML.parse(buffer.join('\n'));
                resolve({
                    metadata: template.Metadata,
                    contents: contents
                });
            });
        });
}

/**
 *
 * @param templateFile
 * @param data {Metacontent}
 * @return {Promise.<Metacontent>} Where the metadata keys have been loaded withexternal contents
 */
let __globalcahce = undefined;
NodeCF.prototype.loadExternals = function(templateFile, data){
    const {metadata, contents} = data;

    if(!metadata.aws.__external){
        return data;
    }

    // Grab the base path to the externals
    let temp = templateFile.split('/');
    temp.splice(-1,1);
    const basePath = temp.join('/');

    let extern = [];

    Object.keys(metadata.aws.__external).map(key => {
        const externalFile = `${basePath}/${metadata.aws.__external[key]}`;
        console.log(`Loading external from ${externalFile}`);
        extern.push(
            readFile(externalFile, 'utf-8').then(externalcontents => {

                // Try to indent substack for YAML
                // This is **broken*, eg it doen't allow repetitions. But Elysium need it this way
                if( /ya?ml/.test(path.extname(templateFile)) ) {

                    if(!__globalcahce){
                        __globalcahce = contents.split('\n')
                    }

                    // Find the placeholder using the brackets - match {{key}} and {{{key}}}
                    const daje = __globalcahce.find( (line) => {  return line.indexOf(`{{${key}}}`) > 0; });

                    // Get the indentation
                    const padding = ' '.repeat(daje.search(/\S/));

                    // And waste some CPU cycles
                    // The first element will be put with the indentation of the template.
                    // unshift breaks the chain, returning the LENGTH instead of the new array - lol
                    const lines = externalcontents.split('\n');
                    const head = lines.shift();
                    externalcontents = lines.map(s => `${padding}${s}`);
                    externalcontents.unshift(head);
                    externalcontents = externalcontents.join('\n');
                }

                return {key, externalcontents}
            })
        )
    });

    return Promise.all(extern).then(aContents => {
        aContents.forEach(ext => { metadata.aws.template[ext.key] = ext.externalcontents; });
        return {metadata, contents};
    });
};


/**
 * Apply the view to the template, returning the rendered template
 * @param data {Metacontent}
 * @return {Promise.<String>} The final template
 */
NodeCF.prototype.render = function(data) {
    return new Promise((resolve, reject) => {
        const {metadata, contents} = data;
        resolve({
            metadata,
            contents: Mustache.render(contents,metadata.aws.template)
        });
    });
};

module.exports = NodeCF;
